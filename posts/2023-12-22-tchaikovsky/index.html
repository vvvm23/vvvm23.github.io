<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TchAIkovsky - Piano MIDI Generation with Transformers | Alex McKinney</title>
<meta name=keywords content><meta name=description content="I&rsquo;ve been learning about machine learning on-and-off since about 2017. I first became interested in the field after stumbling across Andrej Karpathy&rsquo;s classic blog, The Unreasonable Effectiveness of Recurrent Neural Networks. How exactly I came across it is lost to time, however I remember being struck with how impressive (at the time) the outputs were. My programming experience then was limited, so seeing programs capable of generating things – learning from data alone – was eye-opening."><meta name=author content><link rel=canonical href=https://afmck.in/posts/2023-12-22-tchaikovsky/><link crossorigin=anonymous href=/assets/css/stylesheet.min.0fbade1da18e97af7375719317bb9ec325a4f325a425cbb45b6b7c0f5ce82a5d.css integrity="sha256-D7reHaGOl69zdXGTF7uewyWk8yWkJcu0W2t8D1zoKl0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://afmck.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://afmck.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://afmck.in/favicon-32x32.png><link rel=apple-touch-icon href=https://afmck.in/apple-touch-icon.png><link rel=mask-icon href=https://afmck.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://afmck.in/posts/2023-12-22-tchaikovsky/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="TchAIkovsky - Piano MIDI Generation with Transformers"><meta property="og:description" content="I&rsquo;ve been learning about machine learning on-and-off since about 2017. I first became interested in the field after stumbling across Andrej Karpathy&rsquo;s classic blog, The Unreasonable Effectiveness of Recurrent Neural Networks. How exactly I came across it is lost to time, however I remember being struck with how impressive (at the time) the outputs were. My programming experience then was limited, so seeing programs capable of generating things – learning from data alone – was eye-opening."><meta property="og:type" content="article"><meta property="og:url" content="https://afmck.in/posts/2023-12-22-tchaikovsky/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-21T15:26:04+00:00"><meta property="article:modified_time" content="2023-12-21T15:26:04+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TchAIkovsky - Piano MIDI Generation with Transformers"><meta name=twitter:description content="I&rsquo;ve been learning about machine learning on-and-off since about 2017. I first became interested in the field after stumbling across Andrej Karpathy&rsquo;s classic blog, The Unreasonable Effectiveness of Recurrent Neural Networks. How exactly I came across it is lost to time, however I remember being struck with how impressive (at the time) the outputs were. My programming experience then was limited, so seeing programs capable of generating things – learning from data alone – was eye-opening."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://afmck.in/posts/"},{"@type":"ListItem","position":2,"name":"TchAIkovsky - Piano MIDI Generation with Transformers","item":"https://afmck.in/posts/2023-12-22-tchaikovsky/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TchAIkovsky - Piano MIDI Generation with Transformers","name":"TchAIkovsky - Piano MIDI Generation with Transformers","description":"I\u0026rsquo;ve been learning about machine learning on-and-off since about 2017. I first became interested in the field after stumbling across Andrej Karpathy\u0026rsquo;s classic blog, The Unreasonable Effectiveness of Recurrent Neural Networks. How exactly I came across it is lost to time, however I remember being struck with how impressive (at the time) the outputs were. My programming experience then was limited, so seeing programs capable of generating things – learning from data alone – was eye-opening.","keywords":[],"articleBody":" I’ve been learning about machine learning on-and-off since about 2017. I first became interested in the field after stumbling across Andrej Karpathy’s classic blog, The Unreasonable Effectiveness of Recurrent Neural Networks. How exactly I came across it is lost to time, however I remember being struck with how impressive (at the time) the outputs were. My programming experience then was limited, so seeing programs capable of generating things – learning from data alone – was eye-opening.\nThis led me down the deep learning rabbit hole, spending much time trying to get a foothold into understanding how these programs worked. I didn’t have a computer-literate mentor, and there was less of an accessible hobbyist community then, so this was a solo endeavour. I distinctly remember training my first model, literally deep in the snowy Scottish Highlands, written from scratch in Visual Basic.NET, to emulate an XOR gate. Exciting stuff.\nDuring my deep dive, I found examples of generating music using recurrent neural networks, the most memorable to me being this video by Carykh – a Youtuber with a moon named after him. This combined my two great interests at the time, so I decided to emulate the results myself from scratch as my final-year project in high school.\nThis attempt was horribly naive as I was still a beginner programmer. I had no notion of things like using third party libraries, of multiprocessing or hardware acceleration, or pretty much any niceties. Everything was done from scratch, down to matrices implemented as linked lists of lists of lists, to matrix multiplications as single-threaded, nested for loops, all the way to higher order optimisers.\nThe result was the first version of TchAIkovsky – named after Tchaikovsky. This never produced anything remotely resembling music, most likely being too slow to converge, assuming that the implementation was even correct. I curse my past self for losing the source code for this project, as it no doubt would be a fantastic read. I did manage to track down a few screenshots though:\nSnazzy training GUI.\nExcellent and highly extensible code.\nHilariously, part of the project required having an end user, to which I selected my music teacher. Asking a veteran musician to evaluate the musicality of literal random noise is challenging.\nThough I got a good grade, the lack of a satisfactory solution meant this idea of generating music using AI persisted in my head for years to come. As I gained more experience, I occasionally revisited the topic, but without enough fervour to yield results. However, recently I got made redundant (interesting job offers welcome) and consequently acquired time and a knocked ego. I thought a small project close to heart would perk me up, and so I revisited this problem, six years later.\nI apologise for the lengthy introduction, but as this is something close to heart and the origin point of my career, it felt wrong to share this project without the full context.\nThe rest of this blog post will be a technical deep dive into generating music as MIDI using Transformers implemented in JAX and Equinox. I will assume basic knowledge of transformer architectures and JAX, though if you are unfamiliar with these you should still be able to get the jist of this blog. If you would like further technical details on these topics, see The Illustrated Transformer by Jay Alammar and my two blog posts on JAX here and here.\nWhat is MIDI? If you imagine how audio is represented on a computer, you will likely think of a waveform:\nWhich is pretty much, indeed, how raw audio is represented on a computer, as an array of samples.\nThe dimensionality (simply, size) of raw audio is immense. Generally speaking, any data with a temporal element sampled at a high frequency will have a large dimensionality. This does not gel well with the high compute requirements of neural networks, especially those certain architectures with an $O(n^2)$ space complexity with sequence length.\nImagine your favourite piece of music. If the quality is good and it is relatively modern, it was likely sampled at around 44.1kHz – or 44,100 samples per second. For a three minute piece of music, that is 7,938,000 samples in the whole file. Throw in a second channel of audio (stereo) and you get 15,876,000. Compare and contrast with text sequences with thousands of tokens, and images with a couple million pixels at most. Naively plugging in the full sequence into a transformer with its memory-hungry attention layers simply is not possible.\nThere are a number of strategies to deal with this, such as limiting the size of the context window, using a lower sampling rate, using dialated convolutions, sampling in a latent space, and so on. However, if we are simply interested in modelling music and not audio, we actually don’t have to model waveforms directly.\nOne format that specifically represents music is called MIDI or the Musical Instrument Digital Interface. This is a standard interface between digital musical instruments (such as a keyboard) and computers, such that different digital instruments, tools, and computers can interface with each other – rather than having different standards for different manufacturers. It can also be used for recording playbacks of performances, composing music on a computer using a Digital Audio Workstation (DAW), or for storing music on memory constrained devices (such as old consoles).\nKeeping the explanation simple, MIDI is simply a set of instructions for how digital instruments should be played. A MIDI file is then simply an array of instructions from this set. It cannot be played and listened to directly, but can be interpreted and rendered as audio in tandem with a sound-font containing the sound of each instrument we want to use at different pitches and velocities (volumes).\nInstructions include, but are not limited to:\nNote On and Note Off events. Sustain On and Off Pitch bends Volume Start and end of different “MIDI programs” Metadata such as comments Example visualisation of MIDI instructions using the midicsv program\nThis reduces the complexity of our music generation problem significantly. For one, we have a more limited set of instructions that can be present in the data, rather than the large space of values a single sample can take in a waveform, usually a floating point value. Two, rather than generating the actual sound of a particular note (say, the sound of a single key being pressed on a piano) or the combination of multiple notes, the model just needs to generate a few tokens to achieve the same effect. Not only is this easier to model (temporal dependancies over a much shorter distance) but is also less computationally expensive.\nA MIDI file is closer to natural language inputs traditionally given to transformers. Just imagine individual MIDI instructions like the individual characters in an NLP training dataset.\nOf course, before passing text to a transformer, we usually want to tokenize the data into a more compact representation than simply character-by character. The same is true for MIDI data, though it is less apparent how this should be done, and what the effect will be on the final outputs.\nTokenising MIDI data Transformers are great in the sense that they seem to work with any modality, provided you first tokenise the raw data in some way. I was watching a good talk by Lucas Beyer on this recently on Aleksa Gordić’s discord server that said as much: This is very cool, but also a little bit uncool if you look back at all the interesting modality-specific architectures that were commonplace just a few years back. For now, attention is indeed all you need.\nThe difficulty of this depends on the modality. Luckily for us, MIDI makes sense to interpret in a purely sequential manner, which simplifies things somewhat. In addition, it has a known and fixed instruction set, which translates to a limited vocabulary size. If we wanted to, we could basically create a vocabulary of all possible MIDI instructions and events and train our model based on that. Like I alluded to earlier, this is similar to training a character-level NLP model.\nArguably, MIDI can be interpreted a multi-dimensional input if it contains multiple programs. For example, multiple instruments or parts playing simultaneously. However, we can equally interpret this as the concatenation of programs, returning to a sequential perspective. For this project, I focused on piano solo performances with both left and right hands merged into a single program, so a sequential perspective holds here.\nThough modelling the full MIDI instruction set is possible, it doesn’t really make sense to do so.\nFor one, we may not require the full MIDI note range, which runs from 0 to 127. For context, a grand piano only covers from 21 to 108. We may also not need all features (like pitch bend) or are only interested in single program files. Furthermore, It could be more efficient to encode groups of notes that commonly occur together (such as chords) as a single token, rather than explicitly predicting all notes. Finally, modelling the full MIDI specification is a more complex task compared to a subset, and may mandate using a larger model than we are capable of training.\nIn practice, we select a subset of features that we care about. This choice will affect the quality of the downstream generations.\nWhen I first attempted this in 2017, I went for the “piano roll” approach. This is like modelling music like one of those automatically playing pianos, or a music box.\nOld-timey piano roll for use in an automatic piano.\nThe idea is that each column encodes a single note in our chosen note range, with time continuously progressing on the vertical axis. A highlighted region indicates the note should be pressed and naturally nothing indicates that the note should not be pressed. With this, we can encode when a note is either on or off, but not much else.\nIn a computer, we can achieve a similar thing by discretising the MIDI file along the time axis and encoding a 1 for when a particular note is on, and 0 otherwise. Synthesia visualisation of notorious anime OP “Unravel”\nThis has the advantage of modelling full polyphony – where we can have many notes playing at the same time – and having a known amount of tokens per second in the raw file. This is because we have to pick some fixed time step size to discretise our file, and hence know the amount of tokens used for each unit of time.\nHowever, this fixed time step size is also a huge weakness. As we have a fixed sampling frequency, certain patterns in the source MIDI may not be represented accurately in our tokenised version – fast passages, notes that don’t land exactly on the beat, changes in tempo, or performances that include dramatic pauses are also examples of patterns that may not be encoded correctly. This is particularly a problem for MIDI files recorded from a real human performance.\nSecondly, this only encodes whether a note is pressed or not, and misses a lot of other information such as the velocity (volume) of a note, sustain pedal events (a note might be off but still makes sound due to the sustain pedal being depressed), and so on.\nFinally, this approach requires the model predicting all notes in a given timestep at the same time, which is difficult to model.\nI am not sure if this approach can be considered tokenisation in the traditional sense. There are $2^N$ possible Note On and Note Off combinations (where $N$ is the number of values in the selected range), which is our “vocabulary size”. However, we model this as predicting $N$ token sets independently, each with a vocabulary size of $2$. The combination of all these predictions forms one “token”.\nA slightly better approach is to predict Note On and Note Off events sequentially, and add a special advance time token to “move” to the next discrete time step. This results in longer sequence lengths but is easier to model. This also results in ambiguity in how to order tokens in the same MIDI timestep, as any permutation of events decodes to the same MIDI, but is interpreted by the model differently.\nFortunately, since my original attempt, other people have proposed better ways of tokenising MIDI than “what I thought of in my head”. So for this project, I decided to employ a more sophisticated tokenisation scheme, based on the paper Pop Music Transformer from Taiwan AI Labs.\nI feel doing research in MIDI generation must be a pretty sweet deal.\nTheir tokenisation strategy (or at least my understanding of it), named REMI, encodes MIDI files using the following tokens:\nNote On events ranging from 0 to 127. Immediately prior a Note On event, a Velocity token containing the volume of the note to be played. Immediately following a Note On event, the Duration of a note measured from 1-64 in increments of 32th note multiples. Bar token to indicate the start of a new bar and Position tokens with 16 discrete bins to indicate the current position within a bar. Tempo tokens to indicate changes in tempo (how long a note actually is in real time). This is always followed by a Position event. Tempo is represented by a combination of a Tempo class (low, medium, or high) and a Tempo value within the selected Tempo class. Chord tokens with 60 possible values. Interestingly, they still add Note On tokens following the Chord token, meaning this is simply a marker to help the model. This is always immediately followed by a Position event. Some music terminology was used above. Here are some simplified explanations:\nA Bar (or Measure) is a unit of time, containing within it a number of beats defined by the Time signature. For example, if when listening to music you find yourself counting four beats, one bar is four beats. The length in real time of a beat is defined by the tempo, usually measured in beats per minute. A chord is a harmonic set of notes played simultaneously (or close to simultaneously), usually three of more notes. Summary from the Pop Transformer paper on their tokenisation strategy REMI versus “standard” MIDI tokenisation.\nThe use of Duration tokens rather than Note Off events helps to avoid predicting “dangling Note On events”, where the model generates Note On events but no matching Note Off events, which would result in notes being held forever.\nThere is the risk the model doesn’t generate a Duration token, however this is low as they always immediately follow a Note On event, meaning it is easy for the model to understand the relationship between adjacent Note On and Duration tokens, versus potentially distance Note On and Note Off tokens.\nThe Bar and Position tokens are to help the model understand that music has a grid structure to it, as well as how note duration (measured in increments of a full note) relates to the current position in a bar. Although the grid structure of music can be learnt by a model without these tokens, without them it can result in the generated music drifting from a grid like structure for longer generations, as errors slowly accumulate.\nTempo tokens allows us to adjust how much real time is represented by one step of Position. This gives our discrete grid a controllable sampling frequency, allowing to represent a range of speeds accurately.\nSimilar to Bar and Position, it is possible for a model to understand chords without explicit tokens for them, but it is still helpful to include information about it. They encode all possible note roots for the chord (from A to G) and five chord qualities (major, minor, diminished, augmented, dominant) which yields 60 possible Chord tokens. This also explains why we can’t simply decode Chord tokens into MIDI, as we do not include information about which octave the chord is played in. So, it simply serves as a marker and the model still needs to predict the actual notes.\nIt is interesting to note that only Note On, Duration, and Tempo are actually used when decoding the tokenised sequence back to MIDI. The rest are just “helper tokens” for the model to use. It is a pretty cool idea to include tokens purely for helping model understanding and would be a nice idea to explore in other modalities.\nFor example, in autoregressive image models (does anyone use these anymore?) inserting ROW_END tokens.\nWith all that, we have a pretty expressive tokenisation scheme that accurately tokenises MIDI files with all the features we want, namely the ability to handle a range of tempos, different volumes, full polyphony, and more. Rather than implement this myself, I relied on the miditok library which already includes the REMI tokeniser.\nOn top of the REMI tokeniser, I trained a Byte-Pair Encoding (BPE) tokeniser. This will group together commonly occurring token sequences into a single token, repeating this process until the vocabulary reaches some predetermined size. It still contains all tokens in the starting REMI vocabulary, but will also include those additional BPE tokens. My hope by doing this is for common patterns ending up being represented as a single token, for example chords or common sequences.\nTo learn more about how BPE tokenisation actually works, check out this Huggingface course page\nWith all that, we now have a MIDI tokeniser which we can use to encode training data for our model.\nTchAIkovsky Architecture in Equinox The model architecture of TchAIkovsky has never been that complicated. In my first attempt, I used first an RNN followed by a LSTM. As it is 2023, I will be using a transformer decoder, trained from scratch with a simple next-token prediction objective.\nI tend to keep models simple until the problem warrants using fancier techniques. Therefore, the final architecture doesn’t stray far from a vanilla Transformer decoder, as it worked reasonably well with just that – and I didn’t have much interest in heavily tuning the architecture.\nOn the input end, the model uses two sets of learned embeddings: one being the token embeddings and the other position embeddings, up to 1024 positions. The embeddings are summed and passed to the decoder stack.\nThe decoder stack consists of multiple decoder blocks which contain the following:\nA totally normal, multi-head attention layer – nothing but pure, honest full attention here. A totally normal MLP projection from $d$ to $4d$, and back down to $d$. Prenorm layers before the attention and MLP blocks. Parallel arrangement of the Attention and MLP blocks, where the outputs of both are summed, along with the residual. The output layer is just a prenorm followed by a linear projection to the vocabulary size. Nothing fancy here.\nWe basically end up with a GPT-2 style model with parallel attention blocks. There isn’t much else to say, except to not underestimate simpler and smaller models (the final model is ~100M parameters, but decent results can be obtained with half of that) when the problem domain is very constrained. It is much easier to model the distribution of a subset of classical music, versus trying to model all text on the internet.\nThe model code is implemented in Equinox – a neural network API built on top of JAX – after the author recommended I check it out over Flax.\nJAX Training Loop Most of the training loop is implemented in JAX, with the exception of the dataset loader provided by the Miditok library, which is a thin PyTorch dataset wrapper. Batches from this dataset are cast to numpy arrays before being passed to the training step function.\nThough I understand why JAX doesn’t reimplement datasets as good implementations already exists in PyTorch and Tensorflow, I still dislike “polluting” my environment with another large library just for a single feature.\nThe dataset I am using is the GiantMIDI dataset from ByteDance research. This is a collection of classical music performances of, to be honest, varying quality. I say varying quality, as I realised late in the development process that the MIDI files are actually AI generated from audio recordings of performances. This meant that quite a few files were of poor quality. In retrospect, I should have used a different dataset.\nI won’t enumerate the full training code, but you can find it here.\nOne thing to highlight is that thanks to JAX’s excellent device-agnostic design and new distributed Array API, I was able to develop this entirely on a single-GPU machine, then add only a few lines of code to convert it to work with Kaggle’s free 8xTPU VM.\nThe entire commit diff to convert the script to work with 8xTPUs.\nThe model’s small size means it trains pretty quickly – just a few hours. Despite being small, it can struggle with overfitting, so I use a relatively high weight decay and dropout rate.\nOoh, training curves.\nExample Samples With the trained model, we can finally get some samples. The results are not perfect and you will probably find better results in real research work. However, not bad for a quick, hacky project, and orders of magnitude better than my previous attempts.\nNext-token prediction as an objective makes sampling quite flexible, so there are a few ways to prompt the model:\nPrompting from extracts from existing music, varying the length of the prompt and the sampling temperature. Generating fully unconditionally with the option to vary sampling temperature. Conditioning on simple structures, such as chords, scales, and simple motifs. Prompting from existing pieces involves tokenising an existing MIDI file, taking the first $N$ tokens where $N$ is a sample time parameter, and sampling the next token from the model as many times as we desire. If the amount of times to sample from the model is greater than the context length of the model, we simply drop the oldest tokens.\nNaturally, prompting from real music can mean that the generated pieces tend to borrow, or copy verbatim, a lot of the prompt. This can be mitigated by using a higher sampling temperature and by limiting the number of tokens in the prompt – say 100-200 – which then tends to produce interesting results. This method of prompting is most useful for generating continuations on music you already know, which can be quite entertaining to listen to.\nLike I mentioned earlier, a lot of MIDI files from the dataset are of dubious quality, so not all files are suitable for prompting. A few are suitable though, such as this continuation of Gymnopédies by Erik Satie.\nYour browser does not support the video tag. On the other end of the spectrum, we have fully unconditional generation. In this case, we generate from nothing but the start token. This means there is no prompt to rely on, and the model must rely entirely on its own knowledge.\nThe results are naturally less consistent. Anyone who has sampled from an unprompted text model will know this. However, I was happy to know they were not all that bad, and even surprised me with the quality sometimes. This made me relieved as I could demonstrate the model was not simply copying the prompt.\nBelow, I show twelve, relatively un-cherry-picked, unconditional samples, made up of four random seeds and three temperatures:\nSeed 0 - Temperature 0.7 Seed 0 - Temperature 0.8 Seed 0 - Temperature 0.9 Seed 11 - Temperature 0.7 Seed 11 - Temperature 0.8 Seed 11 - Temperature 0.9 Seed 255 - Temperature 0.7 Seed 255 - Temperature 0.8 Seed 255 - Temperature 0.9 Seed 777 - Temperature 0.7 Seed 777 - Temperature 0.8 Seed 777 - Temperature 0.9 A middleground between full unconditional sampling and prompting from files is to prompt from simple structures, such as chord progressions, scales, and motifs. This allows for a degree of controllable, creative generation. I didn’t explore this deeply, but it is an interesting direction to continue on.\nConclusion There are plenty of directions in which this project could be taken further. For example, a more advanced or simply larger model, using a bigger and better dataset, and so on. A cool, more ambitious direction would be to train on the full MIDI instruction set and letting it loose on internet scale datasets – producing a “MIDI foundation model”.\nHowever, I just intended this to be a small, fun project, and would like to move onto other things, so I leave this at that.\nI hope I have perhaps inspired you to try your hand at creating your own MIDI generating model, or just to tackle a similarly small scale problem. There is a lot of emphasis nowadays on Goliath-sized models, and subsequent fine-tuning of them, that it can be somewhat refreshing to return to training smaller models from scratch. Furthermore, projects at this scale are pretty accessible to people with limited compute – I developed on a RTX 3090 machine (though, this is definitely overkill) and trained the final models on Kaggle’s free TPU notebooks, which was an easy transition thanks to JAX’s device agnostic design.\nIf you liked this post please consider following me on Twitter or use this site’s RSS feed for notifications on future ramblings. Alternatively you can navigate to the root of this website and repeatedly refresh until something happens. Thank you for reading this far and I hope you found it useful!\n","wordCount":"4235","inLanguage":"en","datePublished":"2023-12-21T15:26:04Z","dateModified":"2023-12-21T15:26:04Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://afmck.in/posts/2023-12-22-tchaikovsky/"},"publisher":{"@type":"Organization","name":"Alex McKinney","logo":{"@type":"ImageObject","url":"https://afmck.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://afmck.in/ accesskey=h title="Alex McKinney (Alt + H)">Alex McKinney</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://afmck.in/about title=About><span>About</span></a></li><li><a href=https://afmck.in/posts title=Posts><span>Posts</span></a></li><li><a href=https://afmck.in/misc title=Misc><span>Misc</span></a></li><li><a href=https://afmck.in/cv.pdf title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>TchAIkovsky - Piano MIDI Generation with Transformers</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-midi aria-label="What is MIDI?">What is MIDI?</a></li><li><a href=#tokenising-midi-data aria-label="Tokenising MIDI data">Tokenising MIDI data</a></li><li><a href=#tchaikovsky-architecture-in-equinox aria-label="TchAIkovsky Architecture in Equinox">TchAIkovsky Architecture in Equinox</a></li><li><a href=#jax-training-loop aria-label="JAX Training Loop">JAX Training Loop</a></li><li><a href=#example-samples aria-label="Example Samples">Example Samples</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=img/cover.jpg alt="Ilkley Moor Winter Frost."></p><p>I&rsquo;ve been learning about machine learning on-and-off since about 2017. I first became interested in the field after stumbling across <a href=http://karpathy.github.io/2015/05/21/rnn-effectiveness/>Andrej Karpathy&rsquo;s classic blog, The Unreasonable Effectiveness of Recurrent Neural Networks</a>. How exactly I came across it is lost to time, however I remember being struck with how impressive (at the time) the outputs were. My programming experience then was limited, so seeing programs capable of <em>generating things</em> – learning from data alone – was eye-opening.</p><p>This led me down the deep learning rabbit hole, spending much time trying to get a foothold into understanding how these programs worked. I didn&rsquo;t have a computer-literate mentor, and there was less of an accessible hobbyist community then, so this was a solo endeavour. I distinctly remember training my first model, literally deep in the snowy Scottish Highlands, written from scratch in <em>Visual Basic.NET</em>, to emulate an XOR gate. Exciting stuff.</p><p>During my deep dive, I found examples of generating music using recurrent neural networks, the most memorable to me being <a href="https://youtu.be/SacogDL_4JU?si=9bT_yuyljVtWsQp1">this video by Carykh</a> – a Youtuber with a moon named after him. This combined my two great interests at the time, so I decided to emulate the results myself from scratch as my final-year project in high school.</p><p>This attempt was horribly naive as I was still a beginner programmer. I had no notion of things like using third party libraries, of multiprocessing or hardware acceleration, or pretty much any niceties. Everything was done from scratch, down to matrices implemented as linked lists of lists of lists, to matrix multiplications as single-threaded, nested for loops, all the way to higher order optimisers.</p><p>The result was the first version of <strong>TchAIkovsky</strong> – named after Tchaikovsky. This never produced anything remotely resembling music, most likely being too slow to converge, assuming that the implementation was even correct. I curse my past self for losing the source code for this project, as it no doubt would be a fantastic read. I did manage to track down a few screenshots though:</p><p><img loading=lazy src=./img/20231220131924.png alt="Screenshot of the training GUI for TchAIkovsky 2017 edition."></p><blockquote><p>Snazzy training GUI.</p></blockquote><p><img loading=lazy src=./img/20231220131950.png alt="Quote-en-quote excellent and highly extensible code."></p><blockquote><p>Excellent and highly extensible code.</p></blockquote><blockquote><p>Hilariously, part of the project required having an <em>end user</em>, to which I selected my music teacher. Asking a veteran musician to evaluate the musicality of literal random noise is challenging.</p></blockquote><p>Though I got a good grade, the lack of a satisfactory solution meant this idea of generating music using AI persisted in my head for years to come. As I gained more experience, I occasionally revisited the topic, but without enough fervour to yield results. However, recently I got made redundant <strong>(interesting job offers welcome)</strong> and consequently acquired time and a knocked ego. I thought a small project close to heart would perk me up, and so I revisited this problem, six years later.</p><p>I apologise for the lengthy introduction, but as this is something close to heart and the origin point of my career, it felt wrong to share this project without the full context.</p><p>The rest of this blog post will be a technical deep dive into generating music as <strong>MIDI</strong> using <strong>Transformers</strong> implemented in <strong>JAX</strong> and <strong>Equinox</strong>. I will assume basic knowledge of transformer architectures and JAX, though if you are unfamiliar with these you should still be able to get the jist of this blog. If you would like further technical details on these topics, see <a href=http://jalammar.github.io/illustrated-transformer/>The Illustrated Transformer by Jay Alammar</a> and my two blog posts on JAX <a href=https://afmck.in/posts/2023-05-22-jax-post/>here</a> and <a href=https://afmck.in/posts/2023-06-04-flax-post/>here</a>.</p><h3 id=what-is-midi>What is MIDI?<a hidden class=anchor aria-hidden=true href=#what-is-midi>#</a></h3><p>If you imagine how audio is represented on a computer, you will likely think of a waveform:</p><p><img loading=lazy src=./img/20231220130100.png alt="Picture of an audio waveform."></p><p>Which is pretty much, indeed, how raw audio is represented on a computer, as an array of samples.</p><p>The dimensionality (simply, size) of raw audio is immense. Generally speaking, any data with a temporal element sampled at a high frequency will have a large dimensionality. This does not <em>gel well</em> with the high compute requirements of neural networks, especially those <em>certain architectures</em> with an $O(n^2)$ space complexity with sequence length.</p><p>Imagine your favourite piece of music. If the quality is good and it is relatively modern, it was likely sampled at around 44.1kHz – or 44,100 samples per second. For a three minute piece of music, that is 7,938,000 samples in the whole file. Throw in a second channel of audio (stereo) and you get 15,876,000. Compare and contrast with text sequences with thousands of tokens, and images with a couple million pixels at most. Naively plugging in the full sequence into a transformer with its memory-hungry attention layers simply is not possible.</p><p>There are a number of strategies to deal with this, such as limiting the size of the context window, using a lower sampling rate, using dialated convolutions, sampling in a latent space, and so on. However, if we are simply interested in modelling <em>music</em> and not <em>audio</em>, we actually don&rsquo;t have to model waveforms directly.</p><p>One format that specifically represents music is called <strong>MIDI or the Musical Instrument Digital Interface</strong>. This is a standard interface between digital musical instruments (such as a keyboard) and computers, such that different digital instruments, tools, and computers can interface with each other – rather than having different standards for different manufacturers. It can also be used for recording playbacks of performances, composing music on a computer using a Digital Audio Workstation (DAW), or for storing music on memory constrained devices (such as old consoles).</p><p>Keeping the explanation simple, MIDI is simply a set of instructions for how digital instruments should be played. A MIDI file is then simply an array of instructions from this set. <strong>It cannot be played and listened to directly</strong>, but can be interpreted and rendered as audio in tandem with a <em>sound-font</em> containing the sound of each instrument we want to use at different pitches and velocities (volumes).</p><p>Instructions include, but are not limited to:</p><ul><li>Note On and Note Off events.</li><li>Sustain On and Off</li><li>Pitch bends</li><li>Volume</li><li>Start and end of different &ldquo;MIDI programs&rdquo;</li><li>Metadata such as comments</li></ul><p><img loading=lazy src=./img/20231220130302.png alt="Visualisation of MIDI instructions using the midicsv program."></p><blockquote><p>Example visualisation of MIDI instructions using the <a href=https://www.fourmilab.ch/webtools/midicsv/>midicsv</a> program</p></blockquote><p>This reduces the complexity of our music generation problem significantly. For one, we have a more <strong>limited set of instructions</strong> that can be present in the data, rather than the large space of values a single sample can take in a waveform, usually a floating point value. Two, rather than generating the actual sound of a particular note (say, the sound of a single key being pressed on a piano) or the combination of multiple notes, the model just needs to generate a few tokens to achieve the same effect. Not only is this easier to model (temporal dependancies over a much shorter distance) but is also <strong>less computationally expensive</strong>.</p><p>A MIDI file is closer to natural language inputs traditionally given to transformers. Just imagine individual MIDI instructions like the individual characters in an NLP training dataset.</p><p>Of course, before passing text to a transformer, we usually want to tokenize the data into a more compact representation than simply character-by character. The same is true for MIDI data, though it is less apparent how this should be done, and what the effect will be on the final outputs.</p><h3 id=tokenising-midi-data>Tokenising MIDI data<a hidden class=anchor aria-hidden=true href=#tokenising-midi-data>#</a></h3><p>Transformers are great in the sense that they seem to work with any modality, provided you first tokenise the raw data in some way. I was watching a good talk by Lucas Beyer on this recently on Aleksa Gordić&rsquo;s discord server that said as much:
<img loading=lazy src=./img/20231220170844.png alt="Screenshot from Lucas Beyer&amp;rsquo;s talk on Aleksa Gordić&amp;rsquo;s discord server."></p><blockquote><p>This is very cool, but also a little bit uncool if you look back at all the interesting modality-specific architectures that were commonplace just a few years back. For now, attention is indeed all you need.</p></blockquote><p>The difficulty of this depends on the modality. Luckily for us, MIDI makes sense to interpret in a purely sequential manner, which simplifies things somewhat. In addition, it has a known and fixed instruction set, which translates to a limited vocabulary size. If we wanted to, we could basically create a vocabulary of all possible MIDI instructions and events and train our model based on that. Like I alluded to earlier, this is similar to training a character-level NLP model.</p><blockquote><p>Arguably, MIDI can be interpreted a multi-dimensional input if it contains <em>multiple programs</em>. For example, multiple instruments or parts playing simultaneously. However, we can equally interpret this as the <em>concatenation</em> of programs, returning to a sequential perspective. For this project, I focused on piano solo performances with both left and right hands merged into a single program, so a sequential perspective holds here.</p></blockquote><p>Though modelling the full MIDI instruction set is possible, it doesn&rsquo;t really make sense to do so.</p><p>For one, we may not require the full MIDI note range, which runs from 0 to 127. For context, a grand piano only covers from 21 to 108. We may also not need all features (like pitch bend) or are only interested in single program files. Furthermore, It could be more efficient to encode groups of notes that commonly occur together (such as chords) as a single token, rather than explicitly predicting all notes. Finally, modelling the full MIDI specification is a more complex task compared to a subset, and may mandate using a larger model than we are capable of training.</p><p>In practice, we select a subset of features that we care about. This choice will affect the quality of the downstream generations.</p><p>When I first attempted this in 2017, I went for the &ldquo;piano roll&rdquo; approach. This is like modelling music like one of those automatically playing pianos, or a music box.</p><p><img loading=lazy src=./img/20231220130425.png alt="Screenshot of piano roll in an automatic piano."></p><blockquote><p>Old-timey piano roll for use in an automatic piano.</p></blockquote><p>The idea is that each column encodes a single note in our chosen note range, with time continuously progressing on the vertical axis. A highlighted region indicates the note should be pressed and naturally nothing indicates that the note should not be pressed. With this, we can encode when a note is either on or off, but not much else.</p><p>In a computer, we can achieve a similar thing by discretising the MIDI file along the time axis and encoding a 1 for when a particular note is on, and 0 otherwise.
<img loading=lazy src=./img/20231220130505.png alt="Synthesia visualisation of anime opening &amp;ldquo;Unravel&amp;rdquo;"></p><blockquote><p>Synthesia visualisation of notorious anime OP &ldquo;Unravel&rdquo;</p></blockquote><p>This has the advantage of modelling full polyphony – where we can have many notes playing at the same time – and having a known amount of tokens per second in the raw file. This is because we have to pick some fixed time step size to discretise our file, and hence know the amount of tokens used for each unit of time.</p><p>However, this fixed time step size is also a huge weakness. As we have a fixed sampling frequency, certain patterns in the source MIDI may not be represented accurately in our tokenised version – fast passages, notes that don&rsquo;t land exactly on the beat, changes in tempo, or performances that include dramatic pauses are also examples of patterns that may not be encoded correctly. This is particularly a problem for MIDI files recorded from a real human performance.</p><p>Secondly, this only encodes whether a note is pressed or not, and misses a lot of other information such as the velocity (volume) of a note, sustain pedal events (a note might be <em>off</em> but still makes sound due to the sustain pedal being depressed), and so on.</p><p>Finally, this approach requires the model predicting <em>all notes</em> in a given timestep at the same time, which is difficult to model.</p><blockquote><p>I am not sure if this approach can be considered tokenisation in the traditional sense. There are $2^N$ possible Note On and Note Off combinations (where $N$ is the number of values in the selected range), which is our &ldquo;vocabulary size&rdquo;. However, we model this as predicting $N$ token sets independently, each with a vocabulary size of $2$. The combination of all these predictions forms one &ldquo;token&rdquo;.</p></blockquote><p>A slightly better approach is to predict Note On and Note Off events sequentially, and add a special <em>advance time</em> token to &ldquo;move&rdquo; to the next discrete time step. This results in longer sequence lengths but is easier to model. This also results in ambiguity in how to order tokens in the same MIDI timestep, as any permutation of events decodes to the same MIDI, but is interpreted by the model differently.</p><p>Fortunately, since my original attempt, other people have proposed better ways of tokenising MIDI than &ldquo;what I thought of in my head&rdquo;. So for this project, I decided to employ a more sophisticated tokenisation scheme, based on the paper Pop Music Transformer from Taiwan AI Labs.</p><p><img loading=lazy src=./img/20231220130625.png alt="Screenshot of the head of the Pop Music Transformer paper."></p><blockquote><p>I feel doing research in MIDI generation must be a pretty sweet deal.</p></blockquote><p>Their tokenisation strategy (or at least my understanding of it), named REMI, encodes MIDI files using the following tokens:</p><ul><li><strong>Note On</strong> events ranging from 0 to 127.</li><li><strong>Immediately prior</strong> a Note On event, a <strong>Velocity token</strong> containing the volume of the note to be played.</li><li><strong>Immediately following</strong> a Note On event, the <strong>Duration</strong> of a note measured from 1-64 in increments of 32th note multiples.</li><li><strong>Bar token</strong> to indicate the start of a new bar and <strong>Position tokens</strong> with 16 discrete bins to indicate the current position within a bar.</li><li><strong>Tempo tokens</strong> to indicate changes in tempo (how long a note actually is in real time). This is <strong>always followed by</strong> a Position event. Tempo is represented by a combination of a Tempo class (low, medium, or high) and a Tempo value within the selected Tempo class.</li><li><strong>Chord tokens</strong> with 60 possible values. Interestingly, they still add Note On tokens following the Chord token, meaning this is simply a marker to help the model. This is always <strong>immediately followed</strong> by a Position event.</li></ul><blockquote><p>Some music terminology was used above. Here are some simplified explanations:</p><ul><li>A Bar (or Measure) is a unit of time, containing within it a number of beats defined by the <em>Time signature</em>. For example, if when listening to music you find yourself counting four beats, one bar is four beats.</li><li>The length in real time of a beat is defined by the tempo, usually measured in beats per minute.</li><li>A chord is a harmonic set of notes played simultaneously (or close to simultaneously), usually three of more notes.</li></ul></blockquote><p><img loading=lazy src=./img/20231220130648.png alt="Summary table showing the proposed REMI tokenisation scheme."></p><blockquote><p>Summary from the Pop Transformer paper on their tokenisation strategy REMI versus &ldquo;standard&rdquo; MIDI tokenisation.</p></blockquote><p>The use of Duration tokens rather than Note Off events helps to avoid predicting &ldquo;dangling Note On events&rdquo;, where the model generates Note On events but no matching Note Off events, which would result in notes being held forever.</p><blockquote><p>There is the risk the model doesn&rsquo;t generate a Duration token, however this is low as they always immediately follow a Note On event, meaning it is easy for the model to understand the relationship between adjacent Note On and Duration tokens, versus potentially distance Note On and Note Off tokens.</p></blockquote><p>The Bar and Position tokens are to help the model understand that music has a grid structure to it, as well as how note duration (measured in increments of a full note) relates to the current position in a bar. Although the grid structure of music can be learnt by a model without these tokens, without them it can result in the generated music <em>drifting</em> from a grid like structure for longer generations, as errors slowly accumulate.</p><p>Tempo tokens allows us to adjust how much real time is represented by one step of Position. This gives our discrete grid a controllable sampling frequency, allowing to represent a range of speeds accurately.</p><p>Similar to Bar and Position, it is possible for a model to understand chords without explicit tokens for them, but it is still helpful to include information about it. They encode all possible note roots for the chord (from A to G) and five chord qualities (major, minor, diminished, augmented, dominant) which yields 60 possible Chord tokens. This also explains why we can&rsquo;t simply decode Chord tokens into MIDI, as we do not include information about <em>which octave the chord is played in</em>. So, it simply serves as a marker and the model still needs to predict the actual notes.</p><p>It is interesting to note that only Note On, Duration, and Tempo are actually used when decoding the tokenised sequence back to MIDI. The rest are just &ldquo;helper tokens&rdquo; for the model to use. It is a pretty cool idea to include tokens purely for helping model understanding and would be a nice idea to explore in other modalities.</p><blockquote><p>For example, in autoregressive image models (does anyone use these anymore?) inserting <code>ROW_END</code> tokens.</p></blockquote><p>With all that, we have a pretty expressive tokenisation scheme that accurately tokenises MIDI files with all the features we want, namely the ability to handle a range of tempos, different volumes, full polyphony, and more. Rather than implement this myself, I relied on the <a href=https://github.com/Natooz/MidiTok>miditok</a> library which already includes the REMI tokeniser.</p><p>On top of the REMI tokeniser, I trained a <strong>Byte-Pair Encoding (BPE)</strong> tokeniser. This will group together commonly occurring token sequences into a single token, repeating this process until the vocabulary reaches some predetermined size. It still contains all tokens in the starting REMI vocabulary, but will also include those additional BPE tokens. My hope by doing this is for <strong>common patterns ending up being represented as a single token</strong>, for example chords or common sequences.</p><blockquote><p>To learn more about how BPE tokenisation actually works, check out <a href="https://huggingface.co/learn/nlp-course/chapter6/5?fw=pt">this Huggingface course page</a></p></blockquote><p>With all that, we now have a MIDI tokeniser which we can use to encode training data for our model.</p><h3 id=tchaikovsky-architecture-in-equinox>TchAIkovsky Architecture in Equinox<a hidden class=anchor aria-hidden=true href=#tchaikovsky-architecture-in-equinox>#</a></h3><p>The model architecture of TchAIkovsky has never been that complicated. In my first attempt, I used first an RNN followed by a LSTM. As it is 2023, I will be using a transformer decoder, trained from scratch with a simple next-token prediction objective.</p><p>I tend to keep models simple until the problem warrants using fancier techniques. Therefore, the final architecture doesn&rsquo;t stray far from a vanilla Transformer decoder, as it worked reasonably well with just that – and I didn&rsquo;t have much interest in heavily tuning the architecture.</p><p>On the input end, the model uses two sets of learned embeddings: one being the token embeddings and the other position embeddings, <strong>up to 1024 positions</strong>. The embeddings are summed and passed to the decoder stack.</p><p>The decoder stack consists of multiple decoder blocks which contain the following:</p><ul><li>A totally normal, multi-head attention layer – nothing but pure, honest full attention here.</li><li>A totally normal MLP projection from $d$ to $4d$, and back down to $d$.</li><li>Prenorm layers <strong>before</strong> the attention and MLP blocks.</li><li><strong>Parallel arrangement of the Attention and MLP blocks</strong>, where the outputs of both are summed, along with the residual.</li></ul><p>The output layer is just a prenorm followed by a linear projection to the vocabulary size. Nothing fancy here.</p><p>We basically end up with a GPT-2 style model with parallel attention blocks. There isn&rsquo;t much else to say, except <strong>to not underestimate simpler and smaller models</strong> (the final model is ~100M parameters, but decent results can be obtained with half of that) when <strong>the problem domain is very constrained</strong>. It is much easier to model the distribution of a subset of classical music, versus trying to model all text on the internet.</p><p>The model code is implemented in Equinox – a neural network API built on top of JAX – after the author recommended I check it out over Flax.</p><h3 id=jax-training-loop>JAX Training Loop<a hidden class=anchor aria-hidden=true href=#jax-training-loop>#</a></h3><p>Most of the training loop is implemented in JAX, with the exception of the dataset loader provided by the Miditok library, which is a thin PyTorch dataset wrapper. Batches from this dataset are cast to numpy arrays before being passed to the training step function.</p><blockquote><p>Though I understand why JAX doesn&rsquo;t reimplement datasets as good implementations already exists in PyTorch and Tensorflow, I still dislike &ldquo;polluting&rdquo; my environment with another large library just for a single feature.</p></blockquote><p>The dataset I am using is the <a href=https://github.com/bytedance/GiantMIDI-Piano>GiantMIDI</a> dataset from ByteDance research. This is a collection of classical music performances of, to be honest, varying quality. I say varying quality, as I realised late in the development process that the MIDI files are actually AI generated from audio recordings of performances. This meant that quite a few files were of poor quality. In retrospect, I should have used a different dataset.</p><p>I won&rsquo;t enumerate the full training code, but you can find it <a href=https://github.com/vvvm23/tchaikovsky>here</a>.</p><p>One thing to highlight is that thanks to JAX&rsquo;s excellent device-agnostic design and new distributed Array API, I was able to develop this entirely on a single-GPU machine, <strong>then add only a few lines of code to convert it to work with Kaggle&rsquo;s free 8xTPU VM</strong>.</p><p><img loading=lazy src=./img/20231218073518.png alt="Git diff showing commit where I added TPU support."></p><blockquote><p>The entire commit diff to convert the script to work with 8xTPUs.</p></blockquote><p>The model&rsquo;s small size means it trains pretty quickly – just a few hours. Despite being small, it can struggle with overfitting, so I use a relatively high weight decay and dropout rate.</p><p><img loading=lazy src=./img/20231221100131.png alt="Fun Weights and Biases training curves"></p><blockquote><p>Ooh, training curves.</p></blockquote><h3 id=example-samples>Example Samples<a hidden class=anchor aria-hidden=true href=#example-samples>#</a></h3><p>With the trained model, we can finally get some samples. The results are not perfect and you will probably find better results in real research work. However, not bad for a quick, hacky project, and orders of magnitude better than my previous attempts.</p><p>Next-token prediction as an objective makes sampling quite flexible, so there are a few ways to prompt the model:</p><ul><li>Prompting <strong>from extracts from existing music</strong>, varying the length of the prompt and the sampling temperature.</li><li>Generating <strong>fully unconditionally</strong> with the option to vary sampling temperature.</li><li><strong>Conditioning on simple structures</strong>, such as chords, scales, and simple motifs.</li></ul><p>Prompting from existing pieces involves tokenising an existing MIDI file, taking the first $N$ tokens where $N$ is a sample time parameter, and sampling the next token from the model as many times as we desire. If the amount of times to sample from the model is greater than the context length of the model, we simply drop the oldest tokens.</p><p>Naturally, prompting from real music can mean that the generated pieces tend to borrow, or copy verbatim, a lot of the prompt. This can be mitigated by using a higher sampling temperature and by limiting the number of tokens in the prompt – say 100-200 – which then tends to produce interesting results. This method of prompting is most useful for generating continuations on music you already know, which can be quite entertaining to listen to.</p><p>Like I mentioned earlier, a lot of MIDI files from the dataset are of dubious quality, so not all files are suitable for prompting. A few are suitable though, such as this continuation of Gymnopédies by Erik Satie.</p><video width=640 height=480 controls>
<source src=gymnopedies.mp4 type=video/mp4>Your browser does not support the video tag.</video><p>On the other end of the spectrum, we have fully unconditional generation. In this case, we generate from nothing but the start token. This means there is no prompt to rely on, and the model must rely entirely on its own knowledge.</p><p>The results are naturally less consistent. Anyone who has sampled from an unprompted text model will know this. However, I was happy to know they were not all that bad, and even surprised me with the quality sometimes. This made me relieved as I could demonstrate the model was not simply copying the prompt.</p><p>Below, I show twelve, <em>relatively</em> un-cherry-picked, unconditional samples, made up of four random seeds and three temperatures:</p><table><tr><th><figure><figcaption>Seed 0 - Temperature 0.7</figcaption><audio controls src=./audio/uncond-seed0-t7.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 0 - Temperature 0.8</figcaption><audio controls src=./audio/uncond-seed0-t8.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 0 - Temperature 0.9</figcaption><audio controls src=./audio/uncond-seed0-t9.mid.ogg.mp3 type=audio/mp3></audio></figure></th></tr><tr><th><figure><figcaption>Seed 11 - Temperature 0.7</figcaption><audio controls src=./audio/uncond-seed11-t7.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 11 - Temperature 0.8</figcaption><audio controls src=./audio/uncond-seed11-t8.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 11 - Temperature 0.9</figcaption><audio controls src=./audio/uncond-seed11-t9.mid.ogg.mp3 type=audio/mp3></audio></figure></th></tr><tr><th><figure><figcaption>Seed 255 - Temperature 0.7</figcaption><audio controls src=./audio/uncond-seed255-t7.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 255 - Temperature 0.8</figcaption><audio controls src=./audio/uncond-seed255-t8.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 255 - Temperature 0.9</figcaption><audio controls src=./audio/uncond-seed255-t9.mid.ogg.mp3 type=audio/mp3></audio></figure></th></tr><tr><th><figure><figcaption>Seed 777 - Temperature 0.7</figcaption><audio controls src=./audio/uncond-seed777-t7.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 777 - Temperature 0.8</figcaption><audio controls src=./audio/uncond-seed777-t8.mid.ogg.mp3 type=audio/mp3></audio></figure></th><th><figure><figcaption>Seed 777 - Temperature 0.9</figcaption><audio controls src=./audio/uncond-seed777-t9.mid.ogg.mp3></audio></figure></th></tr></table><p>A middleground between full unconditional sampling and prompting from files is to prompt from simple structures, such as chord progressions, scales, and motifs. This allows for a degree of controllable, creative generation. I didn&rsquo;t explore this deeply, but it is an interesting direction to continue on.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>There are plenty of directions in which this project could be taken further. For example, a more advanced or simply larger model, using a bigger and better dataset, and so on. A cool, more ambitious direction would be to train on the full MIDI instruction set and letting it loose on internet scale datasets – producing a &ldquo;MIDI foundation model&rdquo;.</p><p>However, I just intended this to be a small, fun project, and would like to move onto other things, so I leave this at that.</p><p>I hope I have perhaps inspired you to try your hand at creating your own MIDI generating model, or just to tackle a similarly small scale problem. There is a lot of emphasis nowadays on Goliath-sized models, and subsequent fine-tuning of them, that it can be somewhat refreshing to return to training smaller models from scratch. Furthermore, projects at this scale are pretty accessible to people with limited compute – I developed on a RTX 3090 machine (though, this is definitely overkill) and trained the final models on Kaggle&rsquo;s free TPU notebooks, which was an easy transition thanks to JAX&rsquo;s device agnostic design.</p><p><img loading=lazy src=img/image.png alt="It ain&amp;rsquo;t much, but it&amp;rsquo;s honest work."></p><p><em>If you liked this post please consider following me on
<a href=https://twitter.com/alexfmckinney>Twitter</a> or use this site’s RSS feed for
notifications on future ramblings. Alternatively you can navigate to the root of
this website and repeatedly refresh until something happens. Thank you for
reading this far and I hope you found it useful!</em></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://afmck.in/>Alex McKinney</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
<a href=/cheems rel="noopener noreferrer">🐕️</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>